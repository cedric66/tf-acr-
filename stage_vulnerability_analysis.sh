#!/bin/bash

# Multi-Stage Vulnerability Analysis Script
# Scans images at 3 stages: Base, After Package Install, After Build

RESULTS_CSV="image_evaluation/results/stage_vulnerability_analysis.csv"
LOG_DIR="image_evaluation/logs/stages"
mkdir -p "$LOG_DIR"

# Header for CSV
echo "Provider,Stage,ImageName,Grype_High,Grype_Critical,ImageSize_MB" > "$RESULTS_CSV"

# Fix PATH for Docker Desktop credentials
export PATH=$PATH:/Applications/Docker.app/Contents/Resources/bin

scan_image() {
    local provider=$1
    local stage=$2
    local image=$3
    local tag="${provider}-${stage}"
    
    echo "Scanning $provider at stage: $stage ($image)"
    
    # Get image size
    size_bytes=$(docker inspect -f "{{ .Size }}" "$image" 2>/dev/null || echo "0")
    size_mb=$(echo "scale=2; $size_bytes / 1024 / 1024" | bc)
    
    # Grype scan
    grype_out="$LOG_DIR/${tag}_grype.json"
    grype "$image" -o json > "$grype_out" 2>&1
    grype_high=$(grep -o '"severity":"High"' "$grype_out" 2>/dev/null | wc -l | xargs)
    grype_crit=$(grep -o '"severity":"Critical"' "$grype_out" 2>/dev/null | wc -l | xargs)
    
    echo "$provider,$stage,$image,$grype_high,$grype_crit,$size_mb" >> "$RESULTS_CSV"
}

# Stage 1: Base Images
echo "=== Stage 1: Base Images ==="

# Chainguard
docker pull cgr.dev/chainguard/jdk:latest > /dev/null 2>&1 && scan_image "chainguard" "base" "cgr.dev/chainguard/jdk:latest" || echo "chainguard,base,cgr.dev/chainguard/jdk:latest,PULL_FAILED,0,0" >> "$RESULTS_CSV"

docker pull cgr.dev/chainguard/jdk:latest-dev > /dev/null 2>&1 && scan_image "chainguard-dev" "base" "cgr.dev/chainguard/jdk:latest-dev" || echo "chainguard-dev,base,cgr.dev/chainguard/jdk:latest-dev,PULL_FAILED,0,0" >> "$RESULTS_CSV"

# Minimus
docker pull reg.mini.dev/openjdk:17 > /dev/null 2>&1 && scan_image "minimus" "base" "reg.mini.dev/openjdk:17" || echo "minimus,base,reg.mini.dev/openjdk:17,PULL_FAILED,0,0" >> "$RESULTS_CSV"

docker pull reg.mini.dev/openjdk:17-dev > /dev/null 2>&1 && scan_image "minimus-dev" "base" "reg.mini.dev/openjdk:17-dev" || echo "minimus-dev,base,reg.mini.dev/openjdk:17-dev,PULL_FAILED,0,0" >> "$RESULTS_CSV"

# DHI
docker pull dhi.io/amazoncorretto:8-alpine3.22-dev > /dev/null 2>&1 && scan_image "dhi" "base" "dhi.io/amazoncorretto:8-alpine3.22-dev" || echo "dhi,base,dhi.io/amazoncorretto:8-alpine3.22-dev,PULL_FAILED,0,0" >> "$RESULTS_CSV"

# Alpine
docker pull openjdk:17-alpine > /dev/null 2>&1 && scan_image "alpine" "base" "openjdk:17-alpine" || echo "alpine,base,openjdk:17-alpine,PULL_FAILED,0,0" >> "$RESULTS_CSV"

# UBI
docker pull registry.access.redhat.com/ubi8/openjdk-17:latest > /dev/null 2>&1 && scan_image "ubi" "base" "registry.access.redhat.com/ubi8/openjdk-17:latest" || echo "ubi,base,registry.access.redhat.com/ubi8/openjdk-17,PULL_FAILED,0,0" >> "$RESULTS_CSV"

# Stage 2: After Package Installation (simulate adding curl)
echo "=== Stage 2: After Package Installation ==="

# Chainguard-dev (has apk)
docker build -t stage2-chainguard-dev:latest - <<EOF 2>/dev/null
FROM cgr.dev/chainguard/jdk:latest-dev
RUN apk add --no-cache curl || echo "apk failed"
EOF
docker image inspect stage2-chainguard-dev:latest > /dev/null 2>&1 && scan_image "chainguard-dev" "pkg-install" "stage2-chainguard-dev:latest" || echo "chainguard-dev,pkg-install,stage2-chainguard-dev:latest,BUILD_FAILED,0,0" >> "$RESULTS_CSV"

# Minimus-dev (has apk)
docker build -t stage2-minimus-dev:latest - <<EOF 2>/dev/null
FROM reg.mini.dev/openjdk:17-dev
RUN apk add --no-cache curl || echo "apk failed"
EOF
docker image inspect stage2-minimus-dev:latest > /dev/null 2>&1 && scan_image "minimus-dev" "pkg-install" "stage2-minimus-dev:latest" || echo "minimus-dev,pkg-install,stage2-minimus-dev:latest,BUILD_FAILED,0,0" >> "$RESULTS_CSV"

# DHI (Debian-based)
docker build -t stage2-dhi:latest - <<EOF 2>/dev/null
FROM dhi.io/amazoncorretto:8-alpine3.22-dev
RUN apk add --no-cache curl || apt-get update && apt-get install -y curl || echo "install failed"
EOF
docker image inspect stage2-dhi:latest > /dev/null 2>&1 && scan_image "dhi" "pkg-install" "stage2-dhi:latest" || echo "dhi,pkg-install,stage2-dhi:latest,BUILD_FAILED,0,0" >> "$RESULTS_CSV"

# Alpine
docker build -t stage2-alpine:latest - <<EOF 2>/dev/null
FROM openjdk:17-alpine
RUN apk add --no-cache curl
EOF
docker image inspect stage2-alpine:latest > /dev/null 2>&1 && scan_image "alpine" "pkg-install" "stage2-alpine:latest" || echo "alpine,pkg-install,stage2-alpine:latest,BUILD_FAILED,0,0" >> "$RESULTS_CSV"

# UBI
docker build -t stage2-ubi:latest - <<EOF 2>/dev/null
FROM registry.access.redhat.com/ubi8/openjdk-17:latest
USER root
RUN microdnf install -y curl && microdnf clean all
EOF
docker image inspect stage2-ubi:latest > /dev/null 2>&1 && scan_image "ubi" "pkg-install" "stage2-ubi:latest" || echo "ubi,pkg-install,stage2-ubi:latest,BUILD_FAILED,0,0" >> "$RESULTS_CSV"

# Stage 3: After Application Build (use existing built images)
echo "=== Stage 3: After Application Build ==="
docker image inspect java-chainguard:latest > /dev/null 2>&1 && scan_image "chainguard" "app-build" "java-chainguard:latest" || echo "chainguard,app-build,java-chainguard:latest,NOT_FOUND,0,0" >> "$RESULTS_CSV"
docker image inspect java-minimus:latest > /dev/null 2>&1 && scan_image "minimus" "app-build" "java-minimus:latest" || echo "minimus,app-build,java-minimus:latest,NOT_FOUND,0,0" >> "$RESULTS_CSV"
docker image inspect java-dhi:latest > /dev/null 2>&1 && scan_image "dhi" "app-build" "java-dhi:latest" || echo "dhi,app-build,java-dhi:latest,NOT_FOUND,0,0" >> "$RESULTS_CSV"
docker image inspect java-alpine:latest > /dev/null 2>&1 && scan_image "alpine" "app-build" "java-alpine:latest" || echo "alpine,app-build,java-alpine:latest,NOT_FOUND,0,0" >> "$RESULTS_CSV"
docker image inspect java-ubi:latest > /dev/null 2>&1 && scan_image "ubi" "app-build" "java-ubi:latest" || echo "ubi,app-build,java-ubi:latest,NOT_FOUND,0,0" >> "$RESULTS_CSV"

echo "=== Multi-Stage Analysis Complete ==="
cat "$RESULTS_CSV"
